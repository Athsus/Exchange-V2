
import { AptosParserRepo, getTypeTagFullname, StructTag, parseTypeTagOrThrow, u8, u64, u128, print, strToU8, u8str, DummyCache, ActualStringClass, sendPayloadTx, sendPayloadTxAndLog, getSimulationKeys } from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./index";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Hippo_aggregator from './hippo_aggregator';
import * as Sample from './sample';

export const readConfig = (program: Command) => {
  const {config, profile} = program.opts();
  const ymlContent = fs.readFileSync(config, {encoding: "utf-8"});
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return {client, account};
}

const program = new Command();

program
  .name('yarn cli')
  .description('Move TS CLI generated by move-to-ts')
  .requiredOption('-c, --config <path>', 'path to your aptos config.yml (generated with "aptos init")')
  .option('-p, --profile <PROFILE>', 'aptos config profile to use', 'default')


const aggregator_one_step_route = async (X: string,Y: string,E: string,_first_dex_type: string,_first_pool_type: string,_first_is_x_to_y: string,_x_in: string,_y_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const E_ = parseTypeTagOrThrow(E);
  const _first_dex_type_ = u8(_first_dex_type);
  const _first_pool_type_ = u64(_first_pool_type);
  const _first_is_x_to_y_ = _first_is_x_to_y=='true';
  const _x_in_ = u64(_x_in);
  const _y_min_out_ = u64(_y_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_one_step_route(_first_dex_type_, _first_pool_type_, _first_is_x_to_y_, _x_in_, _y_min_out_, [X_, Y_, E_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:one-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_E>')
  .argument('<_first_dex_type>')
  .argument('<_first_pool_type>')
  .argument('<_first_is_x_to_y>')
  .argument('<_x_in>')
  .argument('<_y_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_one_step_route);


const aggregator_swap = async (X: string,Y: string,Z: string,OutCoin: string,E1: string,E2: string,E3: string,_num_steps: string,_first_dex_type: string,_first_pool_type: string,_first_is_x_to_y: string,_second_dex_type: string,_second_pool_type: string,_second_is_x_to_y: string,_third_dex_type: string,_third_pool_type: string,_third_is_x_to_y: string,_x_in: string,_m_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const _num_steps_ = u8(_num_steps);
  const _first_dex_type_ = u8(_first_dex_type);
  const _first_pool_type_ = u64(_first_pool_type);
  const _first_is_x_to_y_ = _first_is_x_to_y=='true';
  const _second_dex_type_ = u8(_second_dex_type);
  const _second_pool_type_ = u64(_second_pool_type);
  const _second_is_x_to_y_ = _second_is_x_to_y=='true';
  const _third_dex_type_ = u8(_third_dex_type);
  const _third_pool_type_ = u64(_third_pool_type);
  const _third_is_x_to_y_ = _third_is_x_to_y=='true';
  const _x_in_ = u64(_x_in);
  const _m_min_out_ = u64(_m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_swap(_num_steps_, _first_dex_type_, _first_pool_type_, _first_is_x_to_y_, _second_dex_type_, _second_pool_type_, _second_is_x_to_y_, _third_dex_type_, _third_pool_type_, _third_is_x_to_y_, _x_in_, _m_min_out_, [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:swap")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_OutCoin>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<_num_steps>')
  .argument('<_first_dex_type>')
  .argument('<_first_pool_type>')
  .argument('<_first_is_x_to_y>')
  .argument('<_second_dex_type>')
  .argument('<_second_pool_type>')
  .argument('<_second_is_x_to_y>')
  .argument('<_third_dex_type>')
  .argument('<_third_pool_type>')
  .argument('<_third_is_x_to_y>')
  .argument('<_x_in>')
  .argument('<_m_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_swap);


const aggregator_swap_with_fees = async (X: string,Y: string,Z: string,OutCoin: string,E1: string,E2: string,E3: string,_num_steps: string,_first_dex_type: string,_first_pool_type: string,_first_is_x_to_y: string,_second_dex_type: string,_second_pool_type: string,_second_is_x_to_y: string,_third_dex_type: string,_third_pool_type: string,_third_is_x_to_y: string,_x_in: string,_m_min_out: string,_fee_to: string,_fee_bips: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const _num_steps_ = u8(_num_steps);
  const _first_dex_type_ = u8(_first_dex_type);
  const _first_pool_type_ = u64(_first_pool_type);
  const _first_is_x_to_y_ = _first_is_x_to_y=='true';
  const _second_dex_type_ = u8(_second_dex_type);
  const _second_pool_type_ = u64(_second_pool_type);
  const _second_is_x_to_y_ = _second_is_x_to_y=='true';
  const _third_dex_type_ = u8(_third_dex_type);
  const _third_pool_type_ = u64(_third_pool_type);
  const _third_is_x_to_y_ = _third_is_x_to_y=='true';
  const _x_in_ = u64(_x_in);
  const _m_min_out_ = u64(_m_min_out);
  const _fee_to_ = new HexString(_fee_to);
  const _fee_bips_ = u8(_fee_bips);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_swap_with_fees(_num_steps_, _first_dex_type_, _first_pool_type_, _first_is_x_to_y_, _second_dex_type_, _second_pool_type_, _second_is_x_to_y_, _third_dex_type_, _third_pool_type_, _third_is_x_to_y_, _x_in_, _m_min_out_, _fee_to_, _fee_bips_, [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:swap-with-fees")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_OutCoin>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<_num_steps>')
  .argument('<_first_dex_type>')
  .argument('<_first_pool_type>')
  .argument('<_first_is_x_to_y>')
  .argument('<_second_dex_type>')
  .argument('<_second_pool_type>')
  .argument('<_second_is_x_to_y>')
  .argument('<_third_dex_type>')
  .argument('<_third_pool_type>')
  .argument('<_third_is_x_to_y>')
  .argument('<_x_in>')
  .argument('<_m_min_out>')
  .argument('<_fee_to>')
  .argument('<_fee_bips>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_swap_with_fees);


const aggregator_swap_with_fixed_output = async (InputCoin: string,OutputCoin: string,E: string,_dex_type: string,_pool_type: string,_is_x_to_y: string,_max_in: string,_amount_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const InputCoin_ = parseTypeTagOrThrow(InputCoin);
  const OutputCoin_ = parseTypeTagOrThrow(OutputCoin);
  const E_ = parseTypeTagOrThrow(E);
  const _dex_type_ = u8(_dex_type);
  const _pool_type_ = u64(_pool_type);
  const _is_x_to_y_ = _is_x_to_y=='true';
  const _max_in_ = u64(_max_in);
  const _amount_out_ = u64(_amount_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_swap_with_fixed_output(_dex_type_, _pool_type_, _is_x_to_y_, _max_in_, _amount_out_, [InputCoin_, OutputCoin_, E_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:swap-with-fixed-output")
  .description("")
  .argument('<TYPE_InputCoin>')
  .argument('<TYPE_OutputCoin>')
  .argument('<TYPE_E>')
  .argument('<_dex_type>')
  .argument('<_pool_type>')
  .argument('<_is_x_to_y>')
  .argument('<_max_in>')
  .argument('<_amount_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_swap_with_fixed_output);


const aggregator_three_step_route = async (X: string,Y: string,Z: string,M: string,E1: string,E2: string,E3: string,_first_dex_type: string,_first_pool_type: string,_first_is_x_to_y: string,_second_dex_type: string,_second_pool_type: string,_second_is_x_to_y: string,_third_dex_type: string,_third_pool_type: string,_third_is_x_to_y: string,_x_in: string,_m_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const M_ = parseTypeTagOrThrow(M);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const _first_dex_type_ = u8(_first_dex_type);
  const _first_pool_type_ = u64(_first_pool_type);
  const _first_is_x_to_y_ = _first_is_x_to_y=='true';
  const _second_dex_type_ = u8(_second_dex_type);
  const _second_pool_type_ = u64(_second_pool_type);
  const _second_is_x_to_y_ = _second_is_x_to_y=='true';
  const _third_dex_type_ = u8(_third_dex_type);
  const _third_pool_type_ = u64(_third_pool_type);
  const _third_is_x_to_y_ = _third_is_x_to_y=='true';
  const _x_in_ = u64(_x_in);
  const _m_min_out_ = u64(_m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_three_step_route(_first_dex_type_, _first_pool_type_, _first_is_x_to_y_, _second_dex_type_, _second_pool_type_, _second_is_x_to_y_, _third_dex_type_, _third_pool_type_, _third_is_x_to_y_, _x_in_, _m_min_out_, [X_, Y_, Z_, M_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:three-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_M>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<_first_dex_type>')
  .argument('<_first_pool_type>')
  .argument('<_first_is_x_to_y>')
  .argument('<_second_dex_type>')
  .argument('<_second_pool_type>')
  .argument('<_second_is_x_to_y>')
  .argument('<_third_dex_type>')
  .argument('<_third_pool_type>')
  .argument('<_third_is_x_to_y>')
  .argument('<_x_in>')
  .argument('<_m_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_three_step_route);


const aggregator_two_step_route = async (X: string,Y: string,Z: string,E1: string,E2: string,_first_dex_type: string,_first_pool_type: string,_first_is_x_to_y: string,_second_dex_type: string,_second_pool_type: string,_second_is_x_to_y: string,_x_in: string,_z_min_out: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const _first_dex_type_ = u8(_first_dex_type);
  const _first_pool_type_ = u64(_first_pool_type);
  const _first_is_x_to_y_ = _first_is_x_to_y=='true';
  const _second_dex_type_ = u8(_second_dex_type);
  const _second_pool_type_ = u64(_second_pool_type);
  const _second_is_x_to_y_ = _second_is_x_to_y=='true';
  const _x_in_ = u64(_x_in);
  const _z_min_out_ = u64(_z_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_two_step_route(_first_dex_type_, _first_pool_type_, _first_is_x_to_y_, _second_dex_type_, _second_pool_type_, _second_is_x_to_y_, _x_in_, _z_min_out_, [X_, Y_, Z_, E1_, E2_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("aggregator:two-step-route")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<_first_dex_type>')
  .argument('<_first_pool_type>')
  .argument('<_first_is_x_to_y>')
  .argument('<_second_dex_type>')
  .argument('<_second_pool_type>')
  .argument('<_second_is_x_to_y>')
  .argument('<_x_in>')
  .argument('<_z_min_out>')
  .argument('[max_gas]', '', '10000')
  .action(aggregator_two_step_route);


const sample_swap_and_transfer = async (X: string,Y: string,Z: string,OutCoin: string,E1: string,E2: string,E3: string,num_steps: string,first_dex_type: string,first_pool_type: string,first_is_x_to_y: string,second_dex_type: string,second_pool_type: string,second_is_x_to_y: string,third_dex_type: string,third_pool_type: string,third_is_x_to_y: string,x_in: string,target_address: string,max_gas: string) => {
  const {client, account} = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const num_steps_ = u8(num_steps);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y=='true';
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y=='true';
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y=='true';
  const x_in_ = u64(x_in);
  const target_address_ = new HexString(target_address);
  const max_gas_ = parseInt(max_gas);
  const payload = Sample.Sample.buildPayload_swap_and_transfer(num_steps_, first_dex_type_, first_pool_type_, first_is_x_to_y_, second_dex_type_, second_pool_type_, second_is_x_to_y_, third_dex_type_, third_pool_type_, third_is_x_to_y_, x_in_, target_address_, [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]);
  await sendPayloadTxAndLog(client, account, payload,{maxGasAmount: max_gas_});
}

program
  .command("sample:swap-and-transfer")
  .description("")
  .argument('<TYPE_X>')
  .argument('<TYPE_Y>')
  .argument('<TYPE_Z>')
  .argument('<TYPE_OutCoin>')
  .argument('<TYPE_E1>')
  .argument('<TYPE_E2>')
  .argument('<TYPE_E3>')
  .argument('<num_steps>')
  .argument('<first_dex_type>')
  .argument('<first_pool_type>')
  .argument('<first_is_x_to_y>')
  .argument('<second_dex_type>')
  .argument('<second_pool_type>')
  .argument('<second_is_x_to_y>')
  .argument('<third_dex_type>')
  .argument('<third_pool_type>')
  .argument('<third_is_x_to_y>')
  .argument('<x_in>')
  .argument('<target_address>')
  .argument('[max_gas]', '', '10000')
  .action(sample_swap_and_transfer);




program.parse();
